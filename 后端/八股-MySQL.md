# MySQL

### Mysql基础架构

* 连接器，用于身份认证和权限相关
* 执行查询语句时会先查询缓存（8.0后移除）
* 分析器，如果没有命中缓存则SQL语句会经过分析器
* 优化器，按照Mysql认为最优的方式执行
* 执行器
* 插件式存储引擎（负责数据的存储和读取，支持InnoDB，MyISAM等)

### Mysql默认存储引擎

5.5.5以前使用MyISAM，之后默认使用InnoDB，只有InnoDB支持事务。

存储引擎基于表而不是数据库

### InnoDB和MyISAM区别

* InnoDB支持**行级锁、MVCC**和表级锁，而MyISAM只支持表级锁
* MyISAM不支持**事务**；InnoDB支持事务并实现了SQL标准的四个隔离级别
* MyISAM不支持**外键**，InnoDB支持
* InnoDB支持异常崩溃后的**恢复**，依赖于redo log。MyISAM不支持
* InnoDB数据文件就是索引文件，叶节点data域保存了完整的数据记录（**聚簇索引**）；MyISAM索引文件和数据文件分离
* InnoDB读写能力随CPU核数增加呈线性增长

### 索引

无论是InnoDB还是MyISAM，都使用**B+树**作为索引结构。但实现方式不太一样。

索引的优缺点：

* 优点是使用索引可以大大**加快**数据的检索速度；使用唯一性索引时可以保证数据库表中每一行数据的**唯一**性
* 缺点是创建和维护索引有开销，降低SQL执行效率。索引需要物理文件存储

哈希索引不支持顺序和范围查询

#### B树/B+树

区别：

* B树的所有节点存放key和数据，而B+树只有叶子结点存放key和数据，其他内节点只存放key
* B树中的叶子节点是独立的，B+树中的叶子节点有指向相邻叶子结点的链
* B+树的检索效率稳定，任何查找都是从根节点到叶子节点

MyISAM是非聚簇索引。索引和数据分开存放。B+树叶子结点data域存放的是**对应数据记录的地址**，找记录时如果指定Key存在，取data域的值作为地址读取响应的数据记录

InnoDB是聚簇索引。数据文件本身就是索引文件，表数据文件本身就是按照B+树组织的一个索引结构。**树的叶节点data域保存了完整的数据记录**。这个**索引的key就是数据库的主键。** 其余的索引作为辅助索引，辅助索引的data域存放的是**相应记录主键的值（而不是地址）**

#### 主键索引与二级索引

主键索引唯一，不为null，一张表只能有一个主键

当InnoDB表中，如果没有显式指定主键索引，InnoDB会检查表中是否有唯一索引且不允许为null值的字段，如果存在则设定为主键索引，否则会生成一个6Byte的自增主键

二级索引分为：普通索引，唯一索引，前缀索引，全文索引等

#### 聚簇索引和非聚簇索引

聚簇索引查找速度快，对范围查找和排序查找优化；但**更新代价大**，且依赖有序数据

非聚簇索引更新的代价比聚簇索引小，因为叶子节点不存放数据。但也依赖于有序的数据，而且有可能会**二次查询/回表**

**非聚簇索引一定会回表吗？**

不一定，比如索引的key就是要查的内容，查到对应的值后直接返回，称为覆盖索引

```sql
SELECT name FROM table WHERE name='guang19';
```

#### 覆盖索引和联合索引

如果一个索引包含所有要查询字段的值，则称为覆盖索引

即要查询的字段刚好是索引的字段，name根据索引可以直接查到数据，而不需要回表查询

使用表中的多个字段创建索引，就是联合索引

#### 最左前缀匹配原则

使用联合索引时，MySQL会根据联合索引中的字段顺序从左到右到查询条件中匹配。如果查询条件中存在与联合索引中最左侧字段相匹配的字段，就会过滤一批数据。或者在执行过程中遇到范围查询（>、<）,对于  **`>=`** 、 **`<=`** 、 **`BETWEEN`** 、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以在使用联合索引时，将区分度最高的字段放在左边。

#### 索引下堆

可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录


### MySQL日志

### MySQL事务

事务是逻辑上的一组操作，要么都执行，要么都不执行

* Atomic 原子性：事务是最小的、**不可分割**的执行单元。动作要么全部完成，要么不起作用
* Consistency 一致性：事务执行前后数据保持一致
* Isolate 隔离性：并发访问数据库时，一个用户的事务不被及其他事务所干扰
* Durability 持久性：一个事务被提交后，对数据库中数据的改变是持久的。
  A、I、D是手段，C是目的
  原子性基于undo log，持久性基于redo log，隔离性基于锁和MVCC

#### 并发事务带来的问题

* **脏读**
  B事务读取了A事务尚未提交的数据，但是A事务回滚了，B读到的就是脏数据
* **丢失修改**
  A事务读取了数据，B事务也读取了数据，在A修改数据后，B也修改的了数据，A做的修改就丢失了。
* **不可重复读**
  A事务要多次读一个数据，在A事务还没结束时，B事务也访问该数据并修改。A事务在两次读取到的数据不一致，称为不可重复读。
* **幻读**
  与不可重复读类似，都是发生在一个事务执行期间。A事务读取了几行数据，B事务往表里插入数据，A事务再读时就会发现一些原本不存在的记录，和幻觉一样，称为幻读。

#### SQL定义的标准事务隔离级别

* **读取未提交**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读，不可重复读、幻读
* **读取已提交**：允许读取并发事务已提交的修改，可以防止脏读，但是幻读和不可重复读仍有可能发生
* **可重复读**：对同一字段的多次读取结果是一致的（除非是事务自己修改的），可以防止脏读和不可重复读，但仍可能发生幻读
* **可串行化**：最高隔离级别，完全服从ACID，所有事务依次执行，事务之间不会产生干扰

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | √   | √         | √   |
| READ-COMMITTED   | ×   | √         | √   |
| REPEATABLE-READ  | ×   | ×         | √   |
| SERIALIZABLE     | ×   | ×         | ×   |

SERIALIZABLE依赖于锁，READ-COMMITTED和REPEATABLE-READ依赖于MVCC

MySQL默认支持的隔离级别是**REPEATABLE-READ可重复读**

#### MySQL并发事务控制方式

基于悲观控制的**锁**和基于乐观控制的**MVCC**

共享锁S锁在读取记录的时候获取、排它锁X锁在修改记录的时候获取

MVCC是多版本并发控制，对一份数据会存储多个版本，通过事务的可见性保证事务能看到自己应该看到的版本。

实现的依赖手段是隐藏字段、read view和undo log

### MySQL锁

表级锁高并发下效率低，但加锁块。行级锁是针对索引字段加的锁，粒度最小，并发度高，加锁的开销大。

InnoDB的行级锁是针对索引字段加的锁，当我们执行UPDATE，DELETE语句时，如果WHERE条件中字段没有命中唯一索引或者索引失效，会导致扫描全表中所有行记录进行加锁

##### InnoDB有哪几类行级锁

* **记录锁（Record Lock）**：属于单个行记录上的锁
* **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身
* **临键锁（Next-Key Lock）**：Record Lock + Gap Lock，锁定范围+记录本身。主要是为了解决幻读问题，记录锁只能锁住已经存在的记录，为了避免插入新纪录，需要依赖间隙锁
  在InnoDB默认的可重复度隔离级别下，行锁默认使用Next-Key Lock。但是如果操作的索引是唯一索引或主键，InnoDB会对锁进行优化，降级为Record Lock，仅锁住索引本身

##### 行级锁和表级锁

由于MVCC的存在，对与一般的SELECT语句，InnoDB不加锁，不过可以显式的加锁

```sql
#共享锁
SELECT ... LOCK IN SHARE MODE
#排它锁
SELECT ... FOR UPDATE
```

##### 意向锁

意向锁是用来快速判断是否可以对某个表使用表锁（加表锁前判断表里有没有行锁）。意向锁是表级锁

* **意向共享锁（Intention Shared Lock，IS 锁）** ：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
* **意向排他锁（Intention Exclusive Lock，IX 锁）** ：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

意向锁是存储引擎维护的，用户无法自己手动操作意向锁，在为数据行获得S锁/X锁前，需要获得对应的意向锁

**意向锁之间是相互兼容的，表级别的意向锁和共享锁/排它锁有部分互斥**

##### 快照读（一致性非锁定读）和当前读（一致性锁定读）

快照读的情况下，如果读取的记录正在执行UPDATE/DELETE操作，读取操作不会等待记录上X锁的释放，而是会读取行的一个快照

只有在读取已提交和可重复读两个隔离级别下，InnoDB才会使用快照读。适合对**数据一致性要求不是特别高**，且追求极致性能的业务场景

* RC下，对于快照数据，快照读总是读取被锁定行的最新一份快照数据
* RR下，对于快照数据，快照读总是读取本事务开始时候的行数据版本

当前读就是给记录加S/X锁

### MySQL性能优化

* 数据库只存储文件地址，文件由文件存储服务负责存储
* IP用整形存储

##### EXPLAIN

##### 读写分离，分库分表
