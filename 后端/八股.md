### 计算机网络

##### TCP三次握手/四次挥手

握手：SYN->SYN+ACK->ACK。本质上是双方各一次握手，各一次确认，只是服务端握手和确认合并

为什么不可以两次握手：**可靠连接依赖于seq序号**，两次握手只能确保客户端的序列号成功被服务端接收，服务端无法确认自己的序列号/同步信号是否被客户端接受（发过去了，但是没有收到客户端的ACK）

为什么不需要四次握手：服务端对客户端的确认，和服务端发送自己的seq可以合并

挥手：FIN->ACK->FIN->ACK

四次挥手的发起方最后有个TIME_WAIT状态，等待2MSL。保证后发起挥手的一方能够收到自己发的ACK（否则自己断开连接了就收不到对方重传的FIN报文）

##### TCP保证可靠传输

序号用于重新排序及去重，校验和，ACK/超时重传，流量控制（滑动窗口），拥塞控制

##### 应用层协议

TCP：HTTP，HTTPS，FTP，SMTP，POP3，IMAP，SSH
UDP：DNS，DHCP

##### HTTPS

基于HTTP，也是使用TCP连接，端口号443，使用SSL/TLS协议做加密和安全验证

使用**非对称加密对秘钥**进行加密，使用**对称加密对报文**进行加密，因为非对称加密效率低

**保密**：客户端生成一个**对称秘钥**，用服务端的公钥加密，传输给服务端，服务端用私钥解密，得到**对称密钥**，随后使用**对称密钥**来进行信息传输

**数字签名**：防止篡改，服务端把自己的内容散列摘要后用自己的私钥加密，附在内容里一起发给客户端。客户端收到后用公钥解密摘要，并且也对内容哈希，比较一下是否一致。

**中间人攻击**：中间人拦截客户端请求，假装自己是服务器，给客户端发自己的公钥。根本原因是***客户端没办法知道收到的公钥是不是服务端的***

**证书**：里面写了证书持有者信息和公钥。只要***证明这个证书没有被篡改过就行***

服务端想要使用HTTPS需要去CA申请数字证书，CA对数字证书进行散列摘要后用CA的私钥对摘要加密得到签名S，并附在证书下方发给服务端。服务端把整个证书发给客户端。客户端用CA的公钥（浏览器里存着）对签名S解密得到摘要，并把证书内容做同样的散列判断和摘要是否一样，判断这个证书有没有被篡改，这样可以保证是在和真实的服务端通信。（防止中间人攻击）

![](https://pic2.zhimg.com/v2-7c78935389af46e197e96d9cd91c06dd_b.jpg)

##### HTTP1.0/HTTP1.1/HTTP2

* HTTP1.0 默认使用短连接，客户端每进行一次HTTP操作，就建立一次连接
* HTTP1.1
  * 有**长连接 keep Alive**，只要客户端服务端没有断开TCP连接，就一直保持连接，可以发送多次HTTP请求。
  * **范围请求**，可以用来断点续传。
  * 支持**管线化**，不需要等待响应直接发送下一个请求，但是客户端还是要按照发送请求的顺序来接收响应，**管线化默认关闭；**
  * **头部加了Host**（用于多个主机名绑定到同一个IP地址的情况）
* HTTP 2
  * **二进制分帧层**传输而不是字符传输；
  * **多路复用：** 单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，一个消息可以分为多个帧，可以根据帧首部的流标识重新组装；（每个逻辑消息是一个对应一个流，然后实际传输的时候分为多个帧）。真正的并发，而不用通过多个TCP连接实现并行
  * **头部压缩**
  * **服务器推送**：服务器根据html中的依赖主动返回所需文件，不用client发起资源请求。但服务器只能借着对客户端的响应推送资源

##### 状态码

* 1 消息状态码
  * 100：客户端应继续
  * 101：切换协议，如新版的HTTP
* 2  **成功**状态码
  * 200：OK 成功
  * 201：已创建，成功请求并创建了新的资源
  * 202：已接受，已经接受请求但未处理完成
* 3 **重定向**状态码
  * 300：多种选择，请求的资源可包括多个位置
  * 301：永久移动，请求的资源永久移动到新URI，浏览器会自动定向到新URI
  * 302：临时移动
  * 304：未修改，一般是浏览器缓存了，然后头信息里指出客户端只希望返回指定日期之后修改的资源
  * 305：应使用代理
* 4 **客户端**错误状态码
  * 400：语法错误，服务端无法理解
  * 403：服务端可以理解请求，但拒绝执行，如非法请求等
  * 404：服务端无法根据客户端请求找到此页面
  * 405：客户端请求中的方法被禁止
* 5 **服务端**错误状态码
  * 500：服务端内部错误
  * 502：Bad Gateway 作为网关的服务器尝试执行请求时，从远程服务器得到无效响应

### 操作系统

##### 进程和线程差别

进程是分配资源的最小单位，线程是执行的最小单位。进程内的线程共享资源，线程切换开销小

##### 死锁

必要条件（非充要条件）：

* 资源是互斥的，一次只能被一个进程使用
* 占有并等待
* 非抢占
* 循环等待

死锁解决：

* 预防：进程执行前是一次性申请需要的全部资源；或者按序申请资源，
* 避免：银行家算法，如果分配资源后系统处于不安全状态，则不分配，迪杰斯特拉提出，但很少使用
* 检测/解除：进程资源分配图查看是否有环

### Linux

##### 你用什么Linux命令

cd , ls , ll , mkdir , touch , cat , vim , tar -zxvf解压  -zcvf压缩，pwd

chmod权限，netstat 看端口,  ifconfig 看网卡信息，top，kill -9 pid

ps -aux | grep

### Redis

##### **Redis为什么这么快**

* 基于内存
* 基于Reactor模式的高效事件处理模型，单线程事件循环和IO多路复用
* 内置多种优化后的数据结构

##### 数据结构

String、List、Hash、Set、ZSet，以及HyperLoglogs、BitMap、Geospatial

##### Redis分布式锁

用Redis的setnx指令，如果key不存在的情况才会设置value。如果设置成功说明没有其他线程获得锁，执行业务前记得设置expire，不然获取锁的服务宕机了就不会释放了，产生死锁。

##### I/O多路复用

同时监听多个套接字，根据当前套接字执行的任务来为套接字关联不同的事件处理器

通过将感兴趣的事件以及类型主车道内核中并监听每个事件是否发生（类似Netty的Selector）

##### RDB/AOF

##### 缓存穿透

查询的Key不合理，所以在Redis中没有，数据库中也没有。这些请求来到数据库上，压力巨大。比如黑客故意制造非法Key发起大量请求

**解决方案：**

* 应用层做好参数校验，不合理的请求直接返回错误
* Redis缓存无效key（缓存空值）
* 布隆过滤器可以判断一个key是否在里面（它说不存在那一定是不存在）由一个bitset和一组hash函数组成

##### **缓存击穿**

请求热点数据，这些数据在数据库里，但不在缓存里，大量读请求打到数据库上，压力巨大

* 热点数据永不过期
* 针对热点数据提前预热，并设置合理的缓存过期时间
* 对同一个key的请求加互斥锁（redis分布式锁），这样保证了只有一个请求来到数据库，拿到结果并刷新缓存

##### **缓存雪崩**

大量热点key设置了同样的过期时间，或者redis宕机。在某一时刻缓存全部失效，导致数据库请求暴增

* 采用Redis集群、限流
* 设置不同的失效时间（设置失效时间的时候增加随机性）
* 增加二级缓存

##### 场景题

* **bitmap统计活跃用户：** 日期为Key，用户ID为offset，登录了为1
