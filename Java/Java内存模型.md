#### **指令重排序**

**编译器优化重排** ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。

**指令并行重排** ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来**将多条指令重叠执行**。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

Java 源代码会经历 **编译器优化重排 —> 指令并行重排 —> 内存系统重排** 的过程，最终才变成操作系统可执行的指令序列。

**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。

一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以**屏蔽系统差异**。

这只是 JMM 存在的其中一个原因。实际上，对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了**抽象了线程和主内存之间的关系**之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。

#### volatile

当使用volatile关键字时，JMM会把该线程本地内存中的变量强制刷新到主内存中去

可以保证可见性，但不能保证原子性。还可以防止指令重排

还能**禁止指令重排序**

所以 `volatile`能够保证，之前的指令一定全部执行，之后的指令一定都没有执行，并且前面语句的结果对后面的语句可见。

#### happens-before

JMM提出了先行发生原则，对程序员做一些保证，总共有8条规则

阐述了操作之间的可见性

程序次序规则（单线程代码执行结果和按序执行一致），监视器锁规则（解锁先行发生于后续加锁），volatile变量规则，线程启动规则

#### 屏障

一种特殊指令，当碰到这条指令时，前面的操作都得完成

写屏障：碰到这条指令，把CPU的store buffer刷入高速缓存，则做的修改都暴露给了其他CPU

读屏障：类似
