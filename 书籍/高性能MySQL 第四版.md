注：私人笔记偏向于整理过去不太了解的点或带来新观点的内容，对较为熟悉的通用概念不做冗余整理

## 第1章 MySQL架构

第一层：客户端，连接处理、身份验证、确保安全

第二层：查询解析、分析、优化以及所有内置函数；存储过程、触发器、视图等

第三层：存储引擎负责MySQL中的数据存储和提取。与Linux下的各种文件系统类似，每种存储引擎间各有优劣。存储引擎不会去解析SQL

![1680250516982](image/高性能MySQL第四版/1680250516982.png)

每个客户端连接都会在服务器进程中拥有一个线程。服务器维护了一个缓冲区，用于存放已就绪的线程，因此不需要为每个新的连接创建或者销毁线程（线程池）

表锁的开销最小，但并发性能当然不好。写锁队列和读锁队列分开，且写锁队列优先级高于读队列。

行锁的加锁开销很大，要跟踪谁拥有这些行级锁、已经锁定了多长时间、行级锁的类型、何时该清理不再需要的行级锁等。

**行级锁是在存储引擎而不是服务器中实现**（比如MyISAM不支持行级锁，InnoDB支持）

**事务是由下层的存储引擎实现的**

有一些命令，当在活动的事务中发出时，会导致MySQL在事务的所有语句执行完毕前提交当前事务。这些通常是进行重大更改的DDL命令，如ALTER TABLE，但LOCK TABLES和其他一些语句也具有同样的效果。

假如在事务中混合使用事务表和非事务表（MyISAM和InnoDB），当需要回滚时，无法撤销对非事务表的修改。所以避免在应用中混合使用存储引擎

MySQL被设计用于在任何给定时间只在一个节点上接受写操作

InnoDB默认为REPEATABLE READ隔离级别，并且通过间隙锁（next-key locking）策略来防止在这个隔离级别上的幻读：InnoDB不只锁定在查询中涉及的行，还会对索引结构中的间隙进行 锁定，以防止幻行被插入。

**因为二级索引（secondary index，非主键索引）需要包含主键列， 如果主键较大，则其他索引也会很大。如果表中的索引较多，主键应当尽量小。**

## 第4章 操作系统和硬件优化


## 第6章 schema设计与管理


## 第7章 创建高性能的索引

## 第8章 查询性能优化

聚簇索引
