注：私人笔记偏向于整理过去不太了解的点或带来新观点的内容，对较为熟悉的通用概念不做冗余整理

## 第1章 MySQL架构

服务器级别层：客户端的连接处理、身份验证、确保安全等

查询执行层：查询解析、分析、优化以及所有内置函数；存储过程、触发器、视图等

存储引擎：存储引擎负责MySQL中的数据存储和提取。与Linux下的各种文件系统类似，每种存储引擎间各有优劣。存储引擎不会去解析SQL

![1680250516982](image/高性能MySQL第四版/1680250516982.png)

每个客户端连接都会在服务器进程中拥有一个线程。服务器维护了一个缓冲区，用于存放已就绪的线程，因此不需要为每个新的连接创建或者销毁线程（线程池）

表锁的开销最小，但并发性能当然不好。写锁队列和读锁队列分开，且写锁队列优先级高于读队列。

行锁的加锁开销很大，要跟踪谁拥有这些行级锁、已经锁定了多长时间、行级锁的类型、何时该清理不再需要的行级锁等。

**行级锁是在存储引擎而不是服务器中实现**（比如MyISAM不支持行级锁，InnoDB支持）

**事务是由下层的存储引擎实现的**

有一些命令，当在活动的事务中发出时，会导致MySQL在事务的所有语句执行完毕前提交当前事务。这些通常是进行重大更改的DDL命令，如ALTER TABLE，但LOCK TABLES和其他一些语句也具有同样的效果。

假如在事务中混合使用事务表和非事务表（MyISAM和InnoDB），当需要回滚时，无法撤销对非事务表的修改。所以避免在应用中混合使用存储引擎

MySQL被设计用于在任何给定时间只在一个节点上接受写操作

InnoDB默认为REPEATABLE READ隔离级别，并且通过间隙锁（next-key locking）策略来防止在这个隔离级别上的幻读：InnoDB不只锁定在查询中涉及的行，还会对索引结构中的间隙进行 锁定，以防止幻行被插入。

**因为二级索引（secondary index，非主键索引）需要包含主键列， 如果主键较大，则其他索引也会很大。如果表中的索引较多，主键应当尽量小。**

## 第4章 操作系统和硬件优化

## 第6章 schema设计与管理

## 第7章 创建高性能的索引

索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。

在MySQL中，索引是在存储引 擎层而不是服务器层实现的。(所以InnoDB是聚簇索引，MyISAM是非聚簇索引)

> 自适应哈希索引。InnoDB存储引擎有一个被称为**自适应哈希索引**的特性。当InnoDB发现某些索引值被非常频繁地被访问时，它会在原有的B-tree索引之上，在内存中再构建一个哈希索引。这就让B-tree索引也具备了一些哈希索引的优势，例如，可以实现非常快速的 哈希查找。这个过程是完全自动化的，用户无法进行控制或者配置。不过，可以通过参数彻底关闭自适应哈希索引这个特性。

B-tree索引通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行。称为覆盖索引

**索引限制：**

> 如果不是按照索引的最左列开始查找，则无法使用索引。
>
> 不能跳过索引中的列：索引了A，B，C三列；索引用于不能指定找特定A+C的情况
>
> 如果查询中有某列的范围查询，则其右边所有列都无法使用索引优化查找。

索引可以让服务器快速地定位到表的指定位置；最常见的B-tree索引，按照顺序存储数据，所以MySQL可以用来做**ORDER BY和GROUP BY操作**。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。

前缀索引是一种能使索引更小、更快的有效办法，但它也有缺点：MySQL无法使用前缀 索引做ORDER BY和GROUP BY操作，也无法使用前缀索引做覆盖扫描。

在多列上独立地创建多个单列索引，在大部分情况下并不能提高MySQL的查询性能。

InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。

因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**

如果你没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引， InnoDB会隐式定义一个主键来作为聚簇索引。

通过二级索引查找行，存储引擎需要找到二级索引的叶子节点，以获得对应的主 键值，然后根据这个值去聚簇索引中查找对应的行。

聚簇索引的每一个叶子节点都包含了**主键值、事务ID、用于事务和MVCC的回滚指针**，以及所有的剩余列

InnoDB的二级索引的叶子节点中存储的是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值作为指针**会让二级索引占用更多的空间**，换来的好处是，**InnoDB在移动行时无须更新二级索引中的这个“指针”**。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应 用。例如，从性能的角度考虑，**使用UUID作为聚簇索引会很糟糕**

使用InnoDB时应该**尽可能地按主键顺序插入数据**，并且尽可能地按照单调增加的聚簇键的值顺序插入新记录



## 第8章 查询性能优化

聚簇索引
